---
title: "16S Functional analysis"
author: "Lisa-Marie Delpech"
date: "20/11/2020"
output:
  html_document:
    toc: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Documentation

As some steps take a lot of computation time, the tables output from Tax4Fun and further curated manualy were saved and loaded again in the script.  

**Input**:  
  
*  rarOTU
*  subsites, subsites.meta  
*  submeta: metadata table with matching samples for the rarefied OTU table  
*  MetaboPath, MetaboPathsubset, KOsubset: tables generated by this script and manually curated or subset to target specific functions or pathways  
*  Align_qual.txt is a file generated with the first step, the script ReadAmplicon.R (not needed if above mentioned tables are loaded)  
*  OTU_single can be generated again with the data formatting script (not needed if above mentioned tables are loaded)  

**Output**:  
  
*  Statistical annalyses on metabolic pathway predictions: PERMANOVA, ANOSIM, RDA  
*  Ordination analyses on the functional prediction (NMDS, PCA)
*  Comparison of targeted functions with a heatmap and associated statistical analyses

**Dependancies**: **Tax4Fun**, **ggplot2**, **Vegan**, **dunn.test**, **AnosimPosthoc.R** (author Christiane Hassenr√ºck, please see: <https://gitlab.leibniz-zmt.de/chh/bioinf>)    
  
# Input data and libraries

## OTU tables

```{r}
rarOTU <- readRDS("./R_data/rarOTU.rds")
subsites <- readRDS("./R_data/subsites.rds")
submeta <- readRDS("./R_data/submeta.rds") # Phys-chem data
subsites.meta <- readRDS("./R_data/subsitesmeta.rds") # Site description file subset to the available metadata
```

## Libraries and sources

```{r, results = 'hide', message = FALSE}
require(vegan)
require(Tax4Fun)
require(dunn.test)
require(ggplot2)
```

```{r}
source("./Sources/AnosimPosthoc.R")
```

# Preparing input for Tax4Fun

Read taxonomy path
To create the table Path, the OTU table with the singletons is needed. This table can be generated with the script **16S_Data_formatting.Rmd**

```{r, eval = FALSE}
Path <- read.table("Align_qual.txt",sep = "\t", h = T, row.names = 1,
                   quote = "", comment.char = "", stringsAsFactors = F)

all.equal(rownames(OTU_single), rownames(Path))
Path_single <- Path
Path <- Path[rownames(rarOTU), ] # Relative to rarefied data
```

Aggregate sequences per taxonomic path

```{r, eval = FALSE}
pathOTU <- aggregate(rarOTU, # samples as columns
                     by = list(as.factor(Path$path)),
                     FUN = sum)

rownames(pathOTU) <- pathOTU$Group.1

pathOTU <- pathOTU[, -1]

Tax4Fun.input <- list(sampleNames = colnames(pathOTU), 
                      otuTable = pathOTU)
```

# Running Tax4Fun

## KEGG orthologs

```{r, eval = FALSE}
Tax4Fun.output <- Tax4Fun(Tax4Fun.input,
                        "~/Desktop/amplicon_analysis_R/SILVA123",
                        fctProfiling = TRUE, # using  the  pre-computed KEGG Ortholog reference profiles
                        refProfile = "UProC", # method for pre-computing reference profiles
                        shortReadMode = FALSE, # computation based on 400 bp reads
                        normCopyNo = TRUE) # adjust for rRNA gene copy number)
```


```{r, eval = FALSE}
KOs <- t(Tax4Fun.output$Tax4FunProfile) * 100
head(KOs[order(rowSums(KOs), decreasing = T), ])
```

## Metabolic pathways

```{r, eval = FALSE}
Tax4Fun.output.2 <- Tax4Fun(Tax4Fun.input,
                        "~/Desktop/amplicon_analysis_R/SILVA123",
                        fctProfiling = FALSE, # using  the  pre-computed KEGG Ortholog reference profiles
                        refProfile = "UProC", # method for pre-computing reference profiles
                        shortReadMode = FALSE, # computation based on 400 bp reads
                        normCopyNo = TRUE) # adjust for rRNA gene copy number)
```

```{r, eval = FALSE}
MetaboPath <- t(Tax4Fun.output.2$Tax4FunProfile) * 100
head(MetaboPath[order(rowSums(MetaboPath), decreasing = T), ])
```

## Curate tables

The tables contain functions that are simply not possible in prokaryotic organisms. Manually curate the tables (metabolic pathways). The KO table is used to investigate specific functions, it was added a column to assign functions to some KOs.

```{r}
# write.table(MetaboPath, file = "MetaboPath.csv", sep = ",")
# write.table(KOs, file = "KOs.csv", sep = ",")

# curate metabolic pathway table in excel and read the table again
# MetaboPath <- read.table(file = "MetaboPath_curated.csv", header = T, sep = ";", row.names = 1)

MetaboPath <- readRDS("./R_data/MetaboPath.rds") # Here load the R table
```

## Relative abundances

```{r}
MetaboPath <- MetaboPath[,-1]
relMetaboPath <- prop.table(t(MetaboPath), 1) * 100 # Matrix needed, samples as rows
```

# Statistical analyses

## ANOSIM & PERMANOVA for compartment and seasonal grouping

```{r}
ANOSIMposthoc(relMetaboPath, subsites$season, distance="bray", padj="fdr") # Bray-Curtis
# All groups different from each other

ANOSIMposthoc(relMetaboPath, subsites$season,distance="jaccard", padj="fdr") # Jaccard
# All groups different from each other

adonis(relMetaboPath ~ subsites$season, permutations= how(nperm=999)) # PERMANOVA for season
adonis(relMetaboPath ~ subsites$type, permutations= how(nperm=999)) # Compare to habitat 
adonis(relMetaboPath[which(subsites$type == "Fjord"),] ~ subsites$season[which(subsites$type == "Fjord")], permutations= how(nperm=999)) # Only the water column
```

Functional turnover

```{r}
ag.Metabo <- data.frame(relMetaboPath) 
  
season.Metabo <- aggregate(ag.Metabo, by = list(subsites$season), FUN="sum") # Aggregate the table per season
rownames(season.Metabo) <- as.character(season.Metabo$Group.1)
season.Metabo <- season.Metabo[,-1]
vegdist(season.Metabo, method="bray", binary=F)
```

## ANOSIM & PERMANOVA for water type grouping

```{r}
ANOSIMposthoc(relMetaboPath, subsites$water, distance="bray", padj="fdr") # Bray-Curtis
# All groups different from rivers and from sediments, fjord sites related

ANOSIMposthoc(relMetaboPath, subsites$water, distance="jaccard", padj="fdr") # Jaccard
 # All groups different from rivers and from sediments, fjord sites related

ANOSIMposthoc(relMetaboPath[which(subsites$season == "August"),], subsites$water[which(subsites$season == "August")], distance="jaccard", padj="fdr")


adonis(relMetaboPath ~ subsites$water, permutations= how(nperm=999)) # For water type

adonis(relMetaboPath[which(subsites$type == "Fjord"),] ~ subsites$season[which(subsites$type == "Fjord")] + subsites$water[which(subsites$type == "Fjord")], permutations = how(nperm = 999)) # Nested PERMANOVA for season + water type only for water column

adonis(relMetaboPath[which(subsites$type == "Fjord"),] ~ subsites$water[which(subsites$type == "Fjord")], permutations = how(nperm = 999))# Within the water column only

adonis(relMetaboPath[which(subsites$season == "August"),] ~ subsites$water[which(subsites$season == "August")], permutations = how(nperm = 999)) # Within the water column only, in August: 37%

adonis(relMetaboPath[which(subsites$season == "June"),] ~ subsites$water[which(subsites$season == "June")], permutations = how(nperm = 999)) # Within the water column only, in June: not significant
```

## RDA with environmental variables

RDA requires Euclidean distances; with *e.g* Hellinger or central log ratio transformation.

```{r}
hellinger_relMetaboPath <- decostand(relMetaboPath, method = "hellinger")
```

### Compute RDA

Format variables

```{r}
hellinger_relMetaboPath.meta <- hellinger_relMetaboPath[rownames(hellinger_relMetaboPath) %in% rownames(submeta),] # Match the dimensions with available metadata
dim(hellinger_relMetaboPath.meta)

names.metabo.RDA <- which(subsites.meta$type == "Fjord" & submeta$DOC != "NA") # 10 samples left out with DOC

Salinity <- submeta$Salinity[names.metabo.RDA]
Temperature <- submeta$Temperature[names.metabo.RDA]
Turbidity <- submeta$Turbidity[names.metabo.RDA]
Depth <- submeta$Station_Depth[names.metabo.RDA]
Secchi <- submeta$Secchi[names.metabo.RDA]
SPM <- submeta$SPM[names.metabo.RDA]
SUVA <- submeta$SUVA254[names.metabo.RDA]
Chla <- submeta$Chla[names.metabo.RDA]
Phaeo <- submeta$Phaeo[names.metabo.RDA]
d13C.POM <- submeta$d13C_POM[names.metabo.RDA]
d15N.POM <- submeta$d15N_POM[names.metabo.RDA]
POC <- submeta$POC[names.metabo.RDA]
CN.POM <- submeta$CN_POM[names.metabo.RDA]
partP <- submeta$PartP[names.metabo.RDA]
partN <- submeta$PartN[names.metabo.RDA]
SiO2 <- submeta$SiO2[names.metabo.RDA]
NO2.NO3 <- submeta$NO2_NO3[names.metabo.RDA]
DOC <- submeta$DOC[names.metabo.RDA]
```

RDA

```{r, eval = FALSE}
metabo.RDA <- rda(hellinger_relMetaboPath.meta[names.metabo.RDA,] ~ Salinity+Temperature+SPM+SUVA+Chla+Phaeo+CN.POM+d15N.POM+d13C.POM+DOC+partP+partN+NO2.NO3+SiO2)
```

### Choose model and perform statistical analysis

```{r, eval = FALSE}
anova.metabo.RDA <- anova(metabo.RDA)
anova.metabo.RDA # Significative (season)

# in: Salinity+Temperature+SPM+SUVA+Chla+Phaeo+CN.POM+d15N.POM+d13C.POM+DOC+partP+partN+NO2.NO3
ordistep.metabo <- ordistep(metabo.RDA) # Salinity + Phaeo + CN.POM + d13C.POM + DOC, 89%, 7% (96%) 
```

Recompute RDA based on ordistep output

```{r}
metabo.RDA <- rda(hellinger_relMetaboPath.meta[names.metabo.RDA,] ~ d13C.POM+DOC+CN.POM+Salinity)
```

Check statistics

```{r}
vif.cca(metabo.RDA) # partN, partP, NO2.NO3, SiO2, POC, Secchi # After ordistep, OK
```

```{r, eval = FALSE}
summary(metabo.RDA) # RDA1 89%, RDA2 8%
```

```{r}
anova.metabo.RDA.terms <- anova(metabo.RDA, by = "term", parallel = 4, perm = how(nperm=100))
anova.metabo.RDA.terms
```

### Plot RDA

```{r, fig.width = 7, fig.height = 7}
scores.metabo.RDA <- scores(metabo.RDA, display=c("sites","cn","bp","sp")) #sites, centroids, biplot
RDA.centroids <- data.frame(scores.metabo.RDA$centroids)
RDA.sites <- data.frame(scores.metabo.RDA$sites)
RDA.biplot <- data.frame(scores.metabo.RDA$biplot)

plot.metabo.RDA <- ggplot(RDA.sites, aes(x = RDA1, y = RDA2)) +
  geom_point(aes(x = RDA1, y = RDA2,
                 col=subsites.meta$water[names.metabo.RDA],
                 shape = subsites.meta$month[names.metabo.RDA]),
             size = 4) +
  scale_colour_manual(values = levels(subsites.meta$waterCol)[2:5]) +
  geom_hline(yintercept=0, linetype="dotted") +
  geom_vline(xintercept=0, linetype="dotted") +
  #coord_fixed() +
  geom_segment(data = RDA.biplot,
               aes(x = 0, xend = RDA1, y = 0, yend = RDA2),
               arrow=arrow(length=unit(0.01,"npc")),
               color = "#C20000") +
  geom_text(data = RDA.biplot, # Remove text and add manually in ppt
            aes(x = RDA1*1.1, y = RDA2*1.1, label=rownames(RDA.biplot)),
            size = 3,
            color = "#C20000") +
  labs(col = "Water type", shape = "Month",
       x = "RDA1 89%", y = "RDA2 8%",
       size = 8) +
  theme_linedraw() +
  theme(panel.grid = element_blank(),
        legend.title = element_text(size = 14),
        legend.text = element_text(size = 12),
        axis.title.x = element_text (size = 16),
        axis.title.y = element_text(size = 16),
        legend.background = element_blank(),
        legend.box.background= element_rect(colour="black"),
        legend.position = c(0.87,0.79))   # c(0.12,0.805) without DOC


plot.metabo.RDA
```

```{r, eval = FALSE, include = FALSE}
ggsave("./Plots/RDA_metabo_season.pdf")
```


# Multivariate ordinations

## NMDS

```{r, fig.height=7, fig.width=7}
NMDS.metabo <- metaMDS(relMetaboPath, trymax = 50, k = 2, distance="bray") # or jaccard
NMDS.metabo$stress #0.06

df.NMDS <- data.frame(NMDS.metabo$points) # get MDS coordinates for each sample

plot.NMDS.metabo <- ggplot(data = df.NMDS,
                    aes(x = MDS1, y = MDS2, col = subsites$season, shape = subsites$season)) +
  geom_point(size = 4) +
  scale_colour_manual(values = c("#A09888","#1B9E77", "#7570B3","#645536")) +
  scale_shape_manual(values = c(18,16,17,15)) +
  labs(col = "Habitat \nand Month", shape = "Habitat \nand Month", x = "NMDS1", y = "NMDS2" ) +
  theme_linedraw() +
  theme(panel.grid = element_blank(),
        axis.ticks = element_blank(),
        legend.position = c(0.125,0.85), # c(0.77,0.828)
        legend.background = element_blank(),
        legend.box.background= element_rect(colour="black"),
        legend.text = element_text(size = 14),
        legend.title = element_text(size = 16),
        axis.title.x = element_text(size = 18),
        axis.title.y = element_text(size = 18),
        axis.text.x = element_blank(),
        axis.text.y = element_blank()) +
  guides(col = guide_legend(ncol=1))

plot.NMDS.metabo
```

```{r, eval = FALSE, include = FALSE}
ggsave(file = "./Plots/NMDS_functions_2.pdf")
```

```{r, eval = FALSE, include = FALSE}
saveRDS(plot.NMDS.metabo, file = "./R_data/plotNMDSmetabo.rds")
```

## PCA

```{r, fig.height=7, fig.width=7}
metabo.PCA <- rda(hellinger_relMetaboPath)

df.PCA.metabo <- data.frame(summary(metabo.PCA)$sites) # get the PC for each site as a data frame

plot.PCA.metabo <- ggplot(data = df.PCA.metabo[,1:2], # PC1 and PC2
                       aes(x = PC1, y = PC2, fill = subsites$season)) +
  geom_point(size = 4, shape = 21, colour = "white") +
  geom_hline(yintercept=0, linetype="dotted") +
  geom_vline(xintercept=0, linetype="dotted") +
  scale_fill_manual(values = levels(subsites$seasonCol)) +
  labs(fill = "Month")+
  theme_linedraw() +
  theme(panel.grid = element_blank()) +
  theme(panel.grid = element_blank(),
        legend.title = element_text(size = 9),
        legend.background = element_blank(),
        legend.box.background= element_rect(colour="black"),
        legend.position = c(0.9,0.125))
plot.PCA.metabo 
```

# Heatmap of targeted metabolic functions

## Gather the relevant information

Create a data frame with relevant functions
KOs were identified and functions manually added in excel

```{r}
function.KOs <- readRDS(file = "./R_data/KOsubset.rds")
# head(function.KOs)
```

```{r}
function.KOs <- function.KOs[which(function.KOs$Function != "NA"),] # dim 79 x 88
# head(function.KOs)
```

Add rows for metabolic pathways (carbon fixation, photosynthesis). Here also, functions were targeted and added manually in the table.

```{r}
function.MetaboPath <- readRDS(file = "./R_data/MetaboPathsubset.rds")
# head(function.MetaboPath)
```

```{r}
function.MetaboPath <- function.MetaboPath[which(function.MetaboPath$Function != "NA"),]
# head(function.MetaboPath)

Functions <- rbind.data.frame(function.KOs, function.MetaboPath) # Gather functions from KOs and metabolic pathways
# Functions
```

Aggregate table per function

```{r}
ag.Functions <- aggregate(Functions[,-1], by = list(Functions$Function), FUN = "sum")
# head(ag.Functions)

rownames(ag.Functions) <- ag.Functions$Group.1
ag.Functions <- ag.Functions[,-1]
# head(ag.Functions)
```

z scale the data to make the different functions comparable

```{r}
ag.Functions <- ag.Functions[-c(1,3,4,5),] # Remove some functions not investigated
scaled.Functions <- scale(t(ag.Functions))
# head(scaled.Functions) # dim 87 x 14
```


## Create the heatmap for seasonal groupings

Create a data frame suitable for ggplot

```{r, eval = FALSE}
heatmap.df <- data.frame(t(scaled.Functions)) # !!! changed order for levels of season (riv,Jun,Aug,sed)
heatmap.df.Aug <- heatmap.df[,which(subsites$season == "August")]
heatmap.df.Jun <- heatmap.df[,which(subsites$season == "June")]
heatmap.df <- heatmap.df[, order(subsites$season)] # order by season 
heatmap.df.Aug <- heatmap.df.Aug[, order(subsites$water[which(subsites$season == "August")])] # order August samples by water type
heatmap.df.Jun <- heatmap.df.Jun[, order(subsites$water[which(subsites$season == "June")])] # order June samples by water type
heatmap.df <- cbind(heatmap.df[,1:11],heatmap.df.Jun, heatmap.df.Aug, heatmap.df[,72:87]) # superpose to seasonal df


nb.functions <- length(rownames(heatmap.df))
func <- rownames(heatmap.df)
df <- data.frame()
for (i in 1:length(colnames(heatmap.df))){
  site <- rep(colnames(heatmap.df)[i], times = nb.functions)
  values <- heatmap.df[,i]
  df0 <- data.frame(site, func, values)
  df <- rbind.data.frame(df, df0)
}
colnames(df) <- c("Sites", "Function", "Values")
heatmap <- df
```

Plot with geom_tile

```{r, eval = FALSE}
plot.Heatmap <- ggplot(data = heatmap) +
  geom_tile(aes(x = Sites, y = Function, fill = Values)) +
  scale_fill_gradient2(high = "#00586C", mid = "#FFFFFF", low = "#B20033", midpoint = 0) +
  labs(fill = element_blank(), x = element_blank(), y = element_blank()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle=75, hjust = 1, color = "black"),
        axis.text.y = element_text(colour="black", size = 16),
        panel.grid = element_blank())
  
plot.Heatmap
```


With facet_grid

```{r, message = FALSE, fig.height=7, fig.width=12}
heatmap.df <- data.frame(t(scaled.Functions)) # !!! changed order for levels of season (riv,Jun,Aug,sed)
heatmap.df.Aug <- heatmap.df[,which(subsites$season == "August")]
heatmap.df.Jun <- heatmap.df[,which(subsites$season == "June")]
heatmap.df.Sed <- heatmap.df[,which(subsites$season == "Sediment")]
heatmap.df.Riv <- heatmap.df[,which(subsites$season == "River")]

heatmap.df <- heatmap.df[, order(subsites$season)] # order by season 
heatmap.df <- cbind(heatmap.df.Riv[,order(subsites$month[which(subsites$season=="River")])], heatmap.df.Jun[,order(subsites$water[which(subsites$season=="June")])], heatmap.df.Aug[,order(subsites$water[which(subsites$season=="August")])], heatmap.df.Sed)
# order rivers by month, June and August by water type

nb.functions <- length(rownames(heatmap.df))
func <- rownames(heatmap.df)
df <- data.frame()
for (i in 1:length(colnames(heatmap.df))){
  site <- rep(colnames(heatmap.df)[i], times = nb.functions)
  values <- heatmap.df[,i]
  df0 <- data.frame(site, func, values, rep(subsites[colnames(heatmap.df)[i],"season"]))
  df <- rbind.data.frame(df, df0)
}
colnames(df) <- c("Sites", "Function", "Values", "Season")
heatmap <- df

levels(heatmap$Function)
heatmap$Function <- factor(heatmap$Function, rev(c("Carbon fixation", "Carbon fixation*", "Photosynthesis", "Nitrogen fixation", "Nitrification", "Denitrification", "Phosphorus utilization", "Sulfate reduction", "Methanogenesis", "Methane oxidation")))

plot.Heatmap.grid <- ggplot(data = heatmap) +
  geom_tile(aes(x = Sites, y = Function, fill = Values)) +
  scale_fill_gradient2(high = "#008DAC", low = "#B20046", mid = "#FFFFFF", midpoint = 0) + #  # high = "#00586C", mid = "#FFFFFF", low = "#B20033"
  facet_grid(. ~ Season, scales = "free", space = "free") +
  labs(fill = element_blank(), x = element_blank(), y = element_blank()) +
  scale_y_discrete(breaks= levels(heatmap$Function), labels= rev(c("Carbon fixation in \nphotosynthetic organisms", "Carbon fixation in \nprokaryotic organisms", "Photosynthesis", "Nitrogen fixation", "Nitrification", "Denitrification", "Phosphorus utilization", "Sulfate reduction", "Methanogenesis", "Methane oxidation"))) +
  theme_linedraw() +
  theme(axis.text.x = element_text(angle=75, hjust = 1, color = "black"), # element_blank(), #
        axis.ticks.x = element_blank(),
        axis.text.y = element_text(colour="black", size = 12),
        panel.grid = element_blank(),
        strip.text.x = element_text(size = 16, color = "black"),
        strip.background.x = element_rect(color = "white", fill = "white"))


plot.Heatmap.grid

```

```{r}
ggsave("./Plots/Function_heatmap.pdf", width = 12, height = 7)
```


## Statistical analyses of targeted functions

Only Dunn's test was used, because data do not all follow a gaussian repartition within each seasonal group (shapiro), or homoscedasticity (bartlett).

Prepare a table suited for analyses

```{r}
t.ag.Functions <- as.data.frame(t(ag.Functions))
head(t.ag.Functions[,1:5])
```


Carbon fixation (in prokaryotes)

```{r}
shapiro.test(t.ag.Functions$`Carbon fixation*`[which(subsites$season == "River")]) # Test within each group
bartlett.test(t.ag.Functions$`Carbon fixation*` ~ subsites$season, data = t.ag.Functions) # not
kruskal.test(t.ag.Functions$`Carbon fixation*` ~ subsites$season, data = t.ag.Functions)
dunn.test(t.ag.Functions$`Carbon fixation*`, subsites$season, method = "bh") # only rivers and sediments are similar


bartlett.test(t.ag.Functions$`Carbon fixation*` ~ subsites$water, data = t.ag.Functions) # not
kruskal.test(t.ag.Functions$`Carbon fixation*` ~ subsites$water, data = t.ag.Functions)
dunn.test(t.ag.Functions[which(subsites$season == "August"),]$`Carbon fixation*`, subsites$water[which(subsites$season == "August")], method = "bh") # Fjord SW ‚â† AdW
```


Carbon fixation in photosynthetic organisms


```{r}
shapiro.test(t.ag.Functions$`Carbon fixation`[which(subsites$season == "River")]) # Test within each group
bartlett.test(t.ag.Functions$`Carbon fixation` ~ subsites$season, data = t.ag.Functions) # OK
kruskal.test(t.ag.Functions$`Carbon fixation`, subsites$season, data = t.ag.Functions)
dunn.test(t.ag.Functions$`Carbon fixation`, subsites$season, method = "bh") # June similar to rivers, Sediments to August
```


Photosynthesis


```{r}
shapiro.test(t.ag.Functions$`Photosynthesis`[which(subsites$season == "River")])
bartlett.test(t.ag.Functions$`Photosynthesis` ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$`Photosynthesis` ~ subsites$season, data = t.ag.Functions)) # June and August are not significatively different from each other
dunn.test(t.ag.Functions$`Photosynthesis`, subsites$season, method = "bh") # only August and sediments are similar

```

Nitrogen fixation

```{r}
shapiro.test(t.ag.Functions$`Nitrogen fixation`[which(subsites$season == "River")])
bartlett.test(t.ag.Functions$`Nitrogen fixation` ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$`Nitrogen fixation` ~ subsites$season, data = t.ag.Functions)) # Only sediments different from other groups, a gredient is visible from June to August
dunn.test(t.ag.Functions$`Nitrogen fixation`, subsites$season, method = "bh") # June and August also different


bartlett.test(t.ag.Functions$`Nitrogen fixation` ~ subsites$water, data = t.ag.Functions) # ok
dunn.test(t.ag.Functions[which(subsites$season == "August"),]$`Nitrogen fixation`, subsites$water[which(subsites$season == "August")], method = "bh") # no difference

```

Nitrification

```{r}
shapiro.test(t.ag.Functions$Nitrification[which(subsites$season == "River")])
bartlett.test(t.ag.Functions$Nitrification ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$Nitrification ~ subsites$season, data = t.ag.Functions)) # Sediments different from the other groups
dunn.test(t.ag.Functions$Nitrification, subsites$season, method = "bh") # Rivers differ too
```

Denitrification

```{r}
shapiro.test(t.ag.Functions$Denitrification[which(subsites$season == "River")])
bartlett.test(t.ag.Functions$Denitrification ~ subsites$season, data = t.ag.Functions) # OK
# TukeyHSD(aov(t.ag.Functions$Denitrification ~ subsites$season, data = t.ag.Functions)) # Only June and August are similar
# TukeyHSD(aov(t.ag.Functions$Denitrification ~ subsites$water, data = t.ag.Functions))

dunn.test(t.ag.Functions$Denitrification, subsites$season, method = "bh")

```

Sulfate reduction

```{r}
shapiro.test(t.ag.Functions$`Sulfate reduction`[which(subsites$season == "River")])
bartlett.test(t.ag.Functions$`Sulfate reduction` ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$`Sulfate reduction` ~ subsites$season, data = t.ag.Functions)) # Each group different from each other
dunn.test(t.ag.Functions$`Sulfate reduction`, subsites$season, method = "bh") # Rivers differ too


TukeyHSD(aov(t.ag.Functions$`Sulfate reduction` ~ subsites$water, data = t.ag.Functions)) # Each group different from each other
bartlett.test(t.ag.Functions$`Sulfate reduction` ~ subsites$water, data = t.ag.Functions) # ok
TukeyHSD(aov(t.ag.Functions[which(subsites$season == "August"),]$`Sulfate reduction` ~ subsites$water[which(subsites$season == "August")]))
dunn.test(t.ag.Functions[which(subsites$season == "August"),]$`Sulfate reduction`, subsites$water[which(subsites$season == "August")], method = "bh") # no difference

```

Methane oxidation

```{r}
shapiro.test(t.ag.Functions$`Methane oxidation`[which(subsites$season == "River")])
bartlett.test(t.ag.Functions$`Methane oxidation` ~ subsites$season, data = t.ag.Functions) # not
kruskal.test(t.ag.Functions$`Methane oxidation` ~ subsites$season, data = t.ag.Functions) # OK
dunn.test(t.ag.Functions$`Methane oxidation`, subsites$season, method = "bh") # only rivers and sediments are similar


bartlett.test(t.ag.Functions$`Methane oxidation` ~ subsites$water, data = t.ag.Functions) # ok
TukeyHSD(aov(t.ag.Functions[which(subsites$season == "August"),]$`Methane oxidation` ~ subsites$water[which(subsites$season == "August")])) # AdW different from the others
```

Methanogenesis

```{r}
shapiro.test(t.ag.Functions$Methanogenesis[which(subsites$season == "River")])
bartlett.test(t.ag.Functions$Methanogenesis ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$Methanogenesis ~ subsites$season, data = t.ag.Functions)) # June and August similar, river different from fjord, sediments different from fjord, rivers and sediments similar
dunn.test(t.ag.Functions$Methanogenesis, subsites$season, method = "bh")
```


Mercury methylation

```{r, eval = FALSE}
shapiro.test(t.ag.Functions$`Mercury methylation`) # OK
bartlett.test(t.ag.Functions$`Mercury methylation` ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$`Mercury methylation` ~ subsites$season, data = t.ag.Functions)) # Sediment and August similar, River and June similar
dunn.test(t.ag.Functions$`Mercury methylation`, subsites$season, method = "bh") # Rivers differ too


bartlett.test(t.ag.Functions$`Mercury methylation` ~ subsites$water, data = t.ag.Functions) # ok
TukeyHSD(aov(t.ag.Functions[which(subsites$season == "August"),]$`Mercury methylation` ~ subsites$water[which(subsites$season == "August")])) # no difference
dunn.test(t.ag.Functions[which(subsites$season == "August"),]$`Mercury methylation`, subsites$water[which(subsites$season == "August")], method = "bh") # no difference

```

Laminarin degradation

```{r, eval = FALSE}
shapiro.test(t.ag.Functions$`Laminarin degradation`) # OK
bartlett.test(t.ag.Functions$`Laminarin degradation` ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$`Laminarin degradation` ~ subsites$season, data = t.ag.Functions)) # Only sediments different from June
dunn.test(t.ag.Functions$`Laminarin degradation`, subsites$season,method = "bh") # June and August differ, sediments from June, August, Rivers

bartlett.test(t.ag.Functions$`Laminarin degradation` ~ subsites$water, data = t.ag.Functions) # ok
dunn.test(t.ag.Functions[which(subsites$water != "AdW"),]$`Laminarin degradation`, subsites$season[which(subsites$water != "AdW")]) # no difference
dunn.test(t.ag.Functions[which(subsites$season == "August"),]$`Laminarin degradation`, subsites$water[which(subsites$season == "August")], method = "bh") # no difference

```

Vitamin B12 synthesis

```{r, eval = FALSE}
shapiro.test(t.ag.Functions$`Cobalamin (Vitamin B12) synthesis`) # OK
bartlett.test(t.ag.Functions$`Cobalamin (Vitamin B12) synthesis` ~ subsites$season, data = t.ag.Functions) # not
dunn.test(t.ag.Functions$`Cobalamin (Vitamin B12) synthesis`, subsites$season,method = "bh") # Only sediments and rivers are similar

dunn.test(t.ag.Functions[which(subsites$season == "August"),]$`Cobalamin (Vitamin B12) synthesis`, subsites$water[which(subsites$season == "August")], method = "bh") # no difference

```

Iron chelation

```{r, eval = FALSE}
shapiro.test(t.ag.Functions$`Iron chelation`) # OK
bartlett.test(t.ag.Functions$`Iron chelation` ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$`Iron chelation` ~ subsites$season, data = t.ag.Functions)) # 
dunn.test(t.ag.Functions$`Iron chelation`, subsites$season, method="bh")
```


Iron binding

```{r, eval = FALSE}
shapiro.test(t.ag.Functions$`Binding of iron ions`) # OK
bartlett.test(t.ag.Functions$`Binding of iron ions` ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$`Binding of iron ions` ~subsites$season, data = t.ag.Functions)) # 
dunn.test(t.ag.Functions$`Binding of iron ions`, subsites$season, method="bh")
```

P utilization

```{r}
shapiro.test(t.ag.Functions$`Phosphorus utilization`) # OK
bartlett.test(t.ag.Functions$`Phosphorus utilization` ~ subsites$season, data = t.ag.Functions) # OK
TukeyHSD(aov(t.ag.Functions$`Phosphorus utilization` ~ subsites$season, data = t.ag.Functions)) # 

dunn.test(t.ag.Functions$`Phosphorus utilization`, subsites$season, method = "bh") # 

```

